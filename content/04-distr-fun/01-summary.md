---
author: xnzone 
title: 概述
date: 2022-09-10 10:23:32
image: /covers/distr-fun.png
cover: false
weight: 5
tags: ["distributed system", "分布式系统"]
---


> 分布式程序是解决相同问题的艺术，你可以用多个计算机解决一个单个计算问题

任何计算系统都需要完成两个基本任务：

- 存储
- 计算

分布式程序是解决相同问题的艺术，你可以用多个计算机解决一个单个计算问题。通常是因为问题不再适用于单个计算机去解决

实际上你没有必要使用分布式系统。给你无限的金钱和无限的R&D时间，你没有必要使用分布式系统。所有的计算和存储可以在一个魔术盒中完成，一个单一的，完全快速和完全可信的系统，你需要支付费用给其他人为你设计一个这样的系统

然而，很少有人有无限的资源。因此，你必须在现实世界中找到一个平衡点。对于小规模，升级硬件是一个广泛的策略。然而，当问题规模持续增长的时候，升级硬件也无法解决单一节点的问题。对此，我欢迎你来到分布式系统的世界

当前的事实是，只要可以通过容错软件降低维护成本，中端的商业硬件价值是最大的

计算能力最开始受益于高端硬件的扩展，你可以用内部存储来替代网络存储。高端硬件的性能优势受制于需要在节点之间大量交互的任务

![](https://gitcode.net/xnzone/solar/-/raw/master/2022/06/2174012.png)

正如上面来自[Barroso, Clidaras & Hölzle ](https://www.morganclaypool.com/doi/abs/10.2200/S00516ED2V01Y201306CAC024)的图所示，假设所有集群节点都是使用一个组合内存，高端和终端硬件之间的性能差别会有所下降

理想情况下，增加一个新机器会线性增加系统的性能和容量。但是，这是不可能的，因为使用单独的计算机会有一些开销。数据需要拷贝，计算任务需要定位等。这是为什么值得学习分布式算法。他们为特定的问题提供了有效的解决方案，同时也有可能性指导，什么是最小成本的实现和什么是不可能的

这篇文章专注于普遍的分布式程序和分布式系统，而不是商业上相关的配置：数据仓库。例如，我将不会讨论由奇怪网络配置和共享内存配置导致的特定问题。另外，关注于浏览系统设计空间而不是优化一些特殊的设计。后者有更多专门的文章介绍

## 我们想要实现的目标：伸缩性和其他好的东西

在我看来，所有的一切都始于处理需要处理问题规模的大小

很多情况都是从小规模开始的，然后一旦达到某个规模，相同的问题就会变得非常复杂。拿起几片巧克力是非常容易的，但是把一座山举起来就非常困难。数一下房间里有几个人是非常容易的，但是很难统计一个国家有多少人

所以，事情起始于规模-可伸缩性。通俗来说，在可伸缩的系统中，因为我们可以由小变大，事情不会变得糟糕。这里是另一种定义：

伸缩性是系统、网络或进程处理不断增长工作量的的一种能力，或者说它的能力可以会随着增长量一起增加

什么是在持续增长？我们可以在很多情况下度量增长量(人口数量，电梯使用率等等)。但是通常有三个感兴趣的特征：

- 规模伸缩性：增加更多的节点可以让系统线性加快；增长数据集不会增加时延
- 地理伸缩性：使用多个数据仓库来降低用户请求的时延是可能的，同时，以某种合理的方式处理多数据中心的时延
- 管理伸缩性：增加更多节点不会增加系统的管理成本(比如机器使用率的管理)

当然，实际上，系统增长会同时发生在不同的方向上，每个指标只能度量增长的某些方面

一个可伸缩的系统是可以持续满足用户增长的。还有两个特殊的相关指标：性能和可用性，也可以用多种方式度量

### 性能(时延)
**性能**的特点是计算机系统完成的有用工作量与使用的时间和资源

根据具体情况，这可能满足下面一个或多个

- 短的响应时间/低延时
- 高吞吐量(处理任务率)
- 计算资源低使用率

在优化这些结果的时候，都要进行权衡取舍。例如，一个系统可以通过处理更大工作量的工作来实现更高的吞吐量，从而减少操作开销。同时由于批量操作，而需要更多的响应时间的权衡。

我发现，低时延-实现更短的响应时间，是性能最感兴趣的方面。因为相比于经济因素，它跟物理限制有强关联的关系。与其他性能相比，用经济资源解决时延更为困难

有很多关于时延的定义，但是我真的很喜欢这个词的词源所表现的意思

**Latency**正在潜伏的(latent)状态；延迟，在初始状态到正在发生的事情的一个阶段。那么什么是"latent"？

这句话的原文是: **Latency**: The state of being latent; delay, a period between the initiation of something and occurrence. And what does it mean to be "latent"?

**Latent** 来自拉丁语，latens, latentis, lateo的现在分词("隐藏的")。存在但不活跃

这个定义非常酷，因为它强调了时延实际上是从某件事发生到它产生影响或变得活跃之间的时间。

例如，假设你现在感染了一种能让人变成僵尸的空气传播病毒。延迟阶段(latent period)就是当你被感染到你变成僵尸的时间。时延(latency)就是已经发生的事情被隐藏起来的时间

让我们假设我们的分布式系统仅做一个高级任务: 给定一个查询，它获取所有的数据并计算得到一个结果。换句话说，把分布式系统视为能在当前内容上运行单个确定性计算(函数)的数据存储：

result = query(all data in the system)

影响时延的不是旧数据的总量，而是系统中起作用的新数据的计算速度。例如，时延在某种意义上被度量为从写数据到读者可见的时长

基于这个定义的一个关键点是，如果没有事情发生，也就没有延迟阶段。一个系统，数据没有变化，也就没有或者不应该有时延问题

在一个分布式系统中，最小时延无法克服：光速的限制了信息传输的速度，并且硬件组成每一个操作也有最小时延的花费(想想RAM和硬件驱动以及CPU)

最小时延对你的查询有多大的影响，取决于这些查询的性质和信息传输需要的物理距离

### 可用性(容错)

一个可伸缩系统的第二个重要方面是可用性

**可用性** 系统处于运行状态的时间比例。如果一个用户不能访问系统，这个时候就说系统是不可用的

分布式系统允许我们实现在单个系统中难以实现的理想特性。例如，单个机器不能容忍任务失败，因为它要么失败，要么成功

分布式系统能够用一堆不可靠的组件，构建一个可靠的系统

没有冗余的系统，只能跟底层组件一样可用。构建有冗余的系统能够容忍部分失败，因此有更高的可用性。值得注意的是，冗余可能意味着不一样的事情，具体取决于你所看到的-组件，服务器，数据中心等等

可用性计算公式 `可用性 = 可用时间 / (可用时间 + 不可用时间)`

从技术的角度来看，可用性主要是关于容错。因为错误发生的可能性会随着组件的增加而增加，系统应该能够进行补偿，以免随着组件数量增加而变得不可靠

例如：

|可用性% |每年允许多少停机时间 |
|---|---|
|90%(一个9)|超过一月|
|99%(两个9)|低于4天|
|99.9%(三个9)|低于9个小时|
|99.99%(四个9)|低于一个小时|
|99.999%(五个9)|大约五分钟|
|99.9999%(六个9)|大约31秒|

可用性在某种意义上是一个比在线时间更广泛的概念，因为服务的可用性也受其他因素影响，比如：网络带宽或者公司服务出口专线(这可能不是容错因素，但是仍然会影响可用性)。但是如果不知道系统每个特定方面的情况下，我们能做的最好的事情就是设计容错

那么什么是容错呢？

**容错** 一旦错误发生的时候，系统以定义好的规则表现

容错归纳为这一点：定义你期望的错误是什么，然后设计一个系统或者算法来容忍他们。你不能容忍你没有考虑到的错误

## 什么阻止了我们实现这些好的东西?

分布式系统由两个物理因素限制了：
- 节点的数量（随着需要的存储和计算能力而增长）
- 两个节点之间的距离（信息传输，最快只能以光速传递）

在这些限制下工作：
- 独立节点数量的增长会增加系统失败的可能性（降低了可用性并增加了部门经费）
- 独立节点数量的增长可能会增加节点间的通信（由于规模增长降低了性能）
- 地理距离的增长会增加节点间通信的时延（某些操作降低了性能）

这些物理限制的结果就是系统设计的选型世界

性能和可用性由外部系统保证。在高层面上，你可以将保证视为系统的SLA(service level agreement)：如果我写数据，多久我能在其他地方访问它？写完数据之后，我有什么保证持久性？如果我让系统运行一个计算任务，多久能够返回结果？当组件失败或者停止运行时，对我的系统有什么影响？

还有另一个标准，没有明确提及但明示：可理解性。所做的保证有多容易理解？当然，对于什么是可理解性没有简单的衡量

我把可理解性放到物理限制下面。毕竟，它是一个物理限制，我们很难理解任务涉及超过我们手指能够移动的事物。错误和异常是有区别的-错误是不正确的表现，而异常是不期望的表现。如果你足够聪明，你不会希望异常发生

## 抽象和模型
这里是抽象和模型发挥作用的地方。抽象让事情更好管理，通过删除与现实世界不相关的方面来解决问题。模型以精确的方式描述了分布式系统的关键特征。我会在下个章节讨论各种各样的模型，例如：
- 系统模型（异步/同步）
- 故障模型（崩溃失败，分区，Byzantine）
- 一致性模型（强，最终）

一个好的抽象会让系统更容易理解，同时更容易捕获与特定目的相关的因素

现实（有很多节点）和理想（像单个系统一样工作）之间存在着紧张的关系。大多数相似的系统是非常昂贵的，例如实现在分布式系统中实现一个共享内存的抽象。

一个系统有更弱的保证也意味着有更多的活动自由，因此潜在的也有更大的性能，但是潜在的也很难理解。相比于节点的集合，人们更容易理解想单个系统工作那样的系统

一个系统可以通过暴露内部系统更多的细节来获得性能。例如，在柱状存储中，人们能够理解键值对在系统中的位置，因此做出影响经典查询性能的决策。隐藏这些细节的系统更容易理解（因为他们表现的更像单个组件，需要考虑的细节更少），然而暴露更多现实世界细节的系统可能有更高的性能（因为他们更接近于现实）

各种各样的故障导致写表现像单个系统的分布式系统是困难的。网络时延和网络分区（例如，在节点之间的网络故障）意味着一个系统有时需要做出艰难的抉择，即保持可用状态会更好，但这会丢失一些强制性保证，或者为了安全起见，当这些故障发生的时候，拒绝客户端

CAP理论-我会在下个章节讨论-讨论了这些紧张的关系。最后，理想的系统既满足程序员的需要（干净的语义）又满足业务需要（可用性/一致性/时延）

## 设计技术：分区和复制
数据集在多个节点间以分布式方式存在是非常重要的。为了任何计算，我们需要定位到数据，然和采取行动

有两个基本技术可以应用于数据集。可以被拆分到多个节点(分区)来允许更多的并行任务。也可以复制或缓存到不同的节点来减少客户端和服务端之间的距离，并实现更高的容错能力(复制)

>归并-我的意思是，分区和复制（Divide and conquer - I mean, partition and replicate ）

下面这张图说明了他们俩的不同：分区数据(A和B)被分配到独立的集合，而复制的数据(C)是被拷贝到多个位置

![](https://gitcode.net/xnzone/solar/-/raw/master/2022/11/1231544.png)

这是解决分布式系统任何问题的两板斧。当然，诀窍在于为你的具体实现选择合适的技术；实现复制和分区有很多算法，每一种都有不同的限制和优点，需要根据你的设计进行评估

### 分区
分区是把数据集分到更小的不同独立的集合；被用来降低数据集增长造成的影响，因此每个分区都是数据的子集

- 分区通过限制数据总量和把相关数据放到同一个分区来提高性能
- 分区通过允许分区独立失败来提高可用性，在牺牲可用性之前增加需要失败的节点数量

分区也是针对特定应用程序，所以不知道特点，很难去说更多关于分区的内容。这也是为什么大部分的文章都聚焦于复制，包括我。分区大部分关于基于你认为的主要访问模式来定义你的分区，处理来自独立分区的限制（比如，跨分区无效访问，不同的增长率等等）

### 复制
复制是在不同的机器上制作多个副本；允许更多服务参与计算

>To replication! The cause of, and solution to all of life's problems

复制-拷贝或再生产某些东西-是我们能降低时延的首要方式

- 复制通过额外的计算能力和适用于新数据的副本带宽来提高性能
- 复制通过创建额外的数据副本提高可用性，在牺牲可用性之前增加需要失败的节点数量

复制是关于提供额外的带宽并在需要的地方缓存。在某些一致性模型中，它还有一致性的问题

复制允许我们实现可伸缩性，性能和故障容忍。害怕降低可用性和降低性能？复制数据是为了避免瓶颈或单个节点故障。降低计算能力？在多个系统上复制计算能力。降低I/O?复制数据到本地缓存来减少时延或多台机器来提高吞吐量

复制也是很多问题的源头，因为数据是非独立的副本，必须要在多台机器间保持同步-这意味着确保副本之间遵循一致性模型

一致性模型是非常重要的：一个好的一致性模型为程序员提供干净的语义（换句话说，保证的特性容易理解），同时也满足业务/设计目标，例如高可用性或强一致性

复制只有一个一致性模型-强一致性-允许你像未复制的数据一样编程。其他一致性模型将复制一些内部信息暴露给程序员。然而，弱一致性模型能够提供低时延和高可用性-这不难理解，只是不同而已

## 推荐阅读
1.The Datacenter as a Computer - An Introduction to the Design of Warehouse-Scale Machines- Barroso & Hölzle, 2008

2 Fallacies of Distributed Computing

3 Notes on Distributed Systems for Young Bloods- Hodges, 2013
