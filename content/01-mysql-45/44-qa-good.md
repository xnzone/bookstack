---
author: 丁奇 
title: 答疑文章（三）
date: 2024-10-18 18:04:00
image: /covers/01-mysql-45.jpg
cover: false
weight: 144
tags: ["MySQL", "实战45讲", "丁奇", "答疑"]
---

## join 的写法

即使在 SQL 语句中写成了 left join，执行过程还是有可能不是从左到右连接的，在被优化器优化后可能变为 join。也就是说，使用 left join 时， 左边的表不一定是驱动表。

如果需要 left join 的语义，就不能把驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面。

join 语句条件是否放到 on 里面，最后优化后都会放到 where 条件里。

## Simple Nested Loop Join 的性能问题

Simple Nested Loop Join 算法相比于 BNL 算法的性能差距在哪：

1. BNL 算法是读取驱动表的数据到 join buffer中，然后遍历被驱动表依次比较 join buffer 中的数据。其比较过程是在内存中完成。
2. SNL 算法是顺序遍历读取驱动表中的每一行数据，到被驱动表中做全表扫描。即使被驱动表数据都在 buffer pool 中，每次查找“下一个记录的操作”，都是类似指针操作。而 join buffer 是数组，遍历的成本更低。
3. SNL 算法对被驱动表做全表扫描时，如果数据没有在 buffer pool 中，就需要等待数据从磁盘读入；从磁盘读入数据到 buffer pool 中，会影响正常业务的命中率，因为被驱动表的数据会多次访问。

## distinct 和 group by 的性能


distinct 的语义是：按照某个字段 a 做分组，相同的 a 的值只返回一行。

group by 在没有聚合函数的情况下，其执行逻辑是一样的，因此性能相同。

执行流程：

1. 创建一个临时表，临时表有一个字段 a ，并且在这个字段 a 上创建一个唯一索引；
2. 遍历表 t，一次取数据插入临时表中；
    1. 如果发现唯一键冲突，就跳过；
    2. 否则插入成功；
3. 遍历完成后，将临时表作为结果集返回给客户端。

## 备库自增主键问题


自增 id 的生成顺序和 binlog 的写入顺序是不同的。

binlog 在记录 insert 语句之前，会先记录 SET INSERT_ID 语句，这个语句表示，这个线程里下一次需要用到自增值的时候，不论当前表的自增值是多少，固定用这个值。因此即使 insert 语句在备库上执行的顺序不同，也不会造成主备数据不一致的问题。